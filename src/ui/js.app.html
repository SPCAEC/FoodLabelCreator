<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const $$ = sel => [...document.querySelectorAll(sel)];

  const state = {
    upc: '',
    item: null,
    exp: '',
    photos: { front: null, ingredients: null },
    pdf: { url: '', id: '' },
    needs: { ingredients: false }
  };

  const isValidUPC = v => /^\d{12}$/.test(String(v || '').trim());
  const isValidDate = v => {
    if (!v) return false;

    // native date input returns "YYYY-MM-DD"
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return true;

    // manual text input "MM/DD/YYYY"
    if (/^(0[1-9]|1[0-2])\/(0[1-9]|[12]\d|3[01])\/\d{4}$/.test(v)) return true;

    return false;
  };

  function setMsg(el, text, type){
    if (!el) return;
    el.textContent = text || '';
    el.className = 'msg';
    if (type) el.classList.add(type);
  }

  function spinner(on, el){
    if (el) {
      el.toggleAttribute('hidden', !on);
      el.style.display = on ? 'inline-block' : 'none';
    }
  }

  function scrollToEl(el) {
    if (!el) return;
    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  function navigate(id) {
    $$('.screen').forEach(s => s.classList.remove('active'));
    const el = document.getElementById(id);
    if (el) {
      el.classList.add('active');
      // Smooth scroll to the top of the newly activated screen
      requestAnimationFrame(() => {
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    } else {
      // fallback scroll if element not found
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }

  function resetApp(){
    Object.assign(state, {
      upc: '',
      item: null,
      exp: '',
      photos: { front: null, ingredients: null },
      pdf: { url: '', id: '' },
      needs: { ingredients: false }
    });

    $('#upcInput').value = '';
    $('#lookupBtn').disabled = true;
    navigate('screenLaunch');
  }

  function wireGlobal(){
    $$('.startOver').forEach(btn => btn.addEventListener('click', resetApp));
  }

  function wireLaunch(){
    const input = $('#upcInput');
    const lookupBtn = $('#lookupBtn');
    const scanBtn = $('#scanBtn');
    const clearBtn = $('#clearBtn');
    const status = $('#launchInfo');
    const load = $('#launchLoad');

    function updateBtn(){
      lookupBtn.disabled = !isValidUPC(input.value);
    }

    input.addEventListener('input', () => {
      input.value = input.value.replace(/\D/g, '').slice(0, 12);
      updateBtn();
    });

    lookupBtn.addEventListener('click', async () => {
      if (lookupBtn.disabled) return;
      state.upc = input.value;
      await doLookup(status, load);
    });

    scanBtn.addEventListener('click', () => {
      setMsg(status, 'Opening scannerâ€¦');
      window.MiniScanner.open();
    });

    clearBtn?.addEventListener('click', () => {
      input.value = '';
      updateBtn();
      setMsg(status, '');
    });

    updateBtn();
    spinner(false, load);
  }

  async function doLookup(statusEl, loadEl){
    setMsg(statusEl, 'Looking up barcodeâ€¦');
    spinner(true, loadEl);
    try {
      const raw = await API.lookup(state.upc); // â†’ expected { ok, data: { found, item } }
      console.log('[RAW LOOKUP RESPONSE]', raw);

      const res = raw?.data || raw;
      console.log('[API LOOKUP RESPONSE]', res);

      if (res && res.found && res.item) {
        console.log('[LOOKUP MATCH]', res.item);
        state.item = normalizeItem(res.item);
        state.exp = formatDateFromSheet(res.item.Expiration); // ðŸ†• preserve expiration
        navigate('screenReview');
        setTimeout(renderReview, 0);
      } else {
        console.log('[LOOKUP NO MATCH]', res);
        state.item = null;
        navigate('screenNew');
      }

      setMsg(statusEl, '');
    } catch (err) {
      console.error('[lookup error]', err);
      setMsg(statusEl, 'Lookup failed.', 'error');
    } finally {
      spinner(false, loadEl);
    }
  }

  window.addEventListener('upc-scanned', async ev => {
    const upc = ev.detail?.upc || '';
    $('#upcInput').value = upc;
    $('#lookupBtn').disabled = !isValidUPC(upc);
    setMsg($('#launchInfo'), 'Scanned âœ“ Looking upâ€¦', 'success');
    spinner(true, $('#launchLoad'));
    try {
      state.upc = upc;
      await doLookup($('#launchInfo'), $('#launchLoad'));
    } catch (e) {
      setMsg($('#launchInfo'), 'Scan failed.', 'error');
    }
    spinner(false, $('#launchLoad'));
  });

  window.addEventListener('upc-scan-canceled', () => {
    setMsg($('#launchInfo'), 'Scanner closed.');
  });

  function normalizeItem(item){
    return {
      upc: String(item.upc || ''),
      brand: String(item.brand || ''),
      productName: String(item.productName || ''),
      flavor: String(item.flavor || ''),
      species: String(item.species || ''),
      lifestage: String(item.lifestage || ''),
      ingredients: String(item.ingredients || ''),
      type: String(item.type || item['Treat or Food'] || '')
    };
  }

  function formatDateFromSheet(date){
    try {
      const d = new Date(date);
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      const yyyy = d.getFullYear();
      return `${mm}/${dd}/${yyyy}`;
    } catch (e) {
      return '';
    }
  }

  function renderReview(){
    const i = state.item || {};
    $('#revExp').value = state.exp || '';
    $('#revSpecies').value = i.species || 'Dog';
    $('#revStage').value = i.lifestage || 'Adult';
    $('#revBrand').value = i.brand || '';
    $('#revName').value = i.productName || '';
    $('#revFlavor').value = i.flavor || '';
    $('#revIngredients').value = i.ingredients || '';
    $('#revTreatFood').value = i.type || 'Food';
  }

  function wireReviewScreen() {
    const saveBtn = $('#revSave');
    const expInput = $('#revExp');
    const typeSelect = $('#revTreatFood');
    const status = $('#revStatus');
    const load = $('#revLoad');

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Hybrid date validation: supports both picker + manual entry
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const isValidDate = v => {
      if (!v) return false;
      // native date picker â†’ "YYYY-MM-DD"
      if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return true;
      // manual entry â†’ "MM/DD/YYYY"
      if (/^(0[1-9]|1[0-2])\/(0[1-9]|[12]\d|3[01])\/\d{4}$/.test(v)) return true;
      return false;
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Enable/disable the Save button
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function updateSaveBtn() {
      const exp = expInput.value.trim();
      const type = typeSelect.value;
      const valid = isValidDate(exp);
      console.log('[updateSaveBtn]', { exp, valid, type });
      saveBtn.disabled = !(valid && (type === 'Food' || type === 'Treat'));

      // Optional: visual feedback
      expInput.classList.toggle('success', valid);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Smart manual date formatting
    // Allows typing 10162025 â†’ 10/16/2025
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    expInput.addEventListener('input', e => {
      // Only auto-format if not using native picker
      if (expInput.type === 'text' || !expInput.value.includes('-')) {
        let v = e.target.value.replace(/\D/g, ''); // digits only

        if (v.length >= 3 && v.length <= 4) {
          // e.g. 101 â†’ 10/1 or 1016 â†’ 10/16
          v = v.replace(/^(\d{2})(\d{1,2})/, '$1/$2');
        } else if (v.length >= 5 && v.length <= 8) {
          // e.g. 10162025 â†’ 10/16/2025
          v = v.replace(/^(\d{2})(\d{2})(\d{0,4}).*/, '$1/$2/$3');
        }

        e.target.value = v;
      }

      updateSaveBtn();
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Ensure date picker selections also trigger validation
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    expInput.addEventListener('change', e => {
      console.log('[expInput change]', e.target.value);
      updateSaveBtn();
    });

    typeSelect.addEventListener('change', updateSaveBtn);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Main save + label creation flow
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    saveBtn.addEventListener('click', async () => {
      const exp = expInput.value.trim();
      const type = typeSelect.value;
      if (!isValidDate(exp) || !type) return;

      Object.assign(state.item, {
        species: $('#revSpecies').value,
        lifestage: $('#revStage').value,
        brand: $('#revBrand').value.trim(),
        productName: $('#revName').value.trim(),
        flavor: $('#revFlavor').value.trim(),
        ingredients: $('#revIngredients').value.trim(),
        type
      });

      state.exp = exp;

      setMsg(status, 'Generating labelâ€¦');
      spinner(true, load);

      try {
        const res = await API.createLabels({
          upc: state.upc,
          ...state.item,
          expiration: exp
        });

        console.log('[LABEL RESPONSE]', res);

        if (!res?.ok || !res?.data?.pdfUrl) {
          setMsg(status, 'Label creation failed.', 'error');
          spinner(false, load);
          return;
        }

        const { pdfUrl, fileId } = res.data;
        state.pdf = { url: pdfUrl, id: fileId };

        // âœ… Update UI + open PDF
        const link = $('#pdfLink');
        const block = $('#pdfLinkBlock');
        if (link && block) {
          link.href = pdfUrl;
          link.textContent = 'View Label PDF';
          block.classList.remove('hidden');
        }

        window.open(pdfUrl, '_blank');
        setMsg(status, 'Label created successfully!', 'success');
      } catch (err) {
        console.error('[create label error]', err);
        setMsg(status, 'Failed to create label.', 'error');
      } finally {
        spinner(false, load);
      }
    });

    updateSaveBtn();
  }

  function wireNewItem(){
    const msg = $('#newStatus');
    const spin = $('#newLoad');
    const next = $('#photoContinue');
    const actions = $('#photoActions');
    const ingBlock = $('#ingredientsBlock');

    $('#frontBtn')?.addEventListener('click', () => {
      captureImage(dataUrl => {
        state.photos.front = dataUrl;
        $('#frontPreview').src = dataUrl;
        $('#frontPreview').classList.remove('hidden');
        ingBlock?.classList.remove('hidden');
        checkReady();
      });
    });

    $('#ingredientsBtn')?.addEventListener('click', () => {
      captureImage(dataUrl => {
        state.photos.ingredients = dataUrl;
        $('#ingredientsPreview').src = dataUrl;
        $('#ingredientsPreview').classList.remove('hidden');
        checkReady();
      });
    });

    next?.addEventListener('click', async () => {
      const front = state.photos.front;
      const ing = state.photos.ingredients;

      if (!front || !ing || front.length < 100 || ing.length < 100) {
        setMsg(msg, 'Missing or invalid image(s).', 'error');
        return;
      }

      setMsg(msg, 'Extracting label dataâ€¦', 'success');
      spinner(true, spin);

      try {
        const extracted = await API.extract({
          frontDataUrl: front,
          ingDataUrl: ing
        });

        if (!extracted?.ok || typeof extracted.data !== 'object') {
          throw new Error('AI extract failed');
        }

        state.item = normalizeItem({
          upc: state.upc,
          ...extracted.data
        });

        navigate('screenReview');
        renderReview();

      } catch (err) {
        console.error('[extract error]', err);
        setMsg(msg, 'AI extraction failed.', 'error');
      } finally {
        spinner(false, spin);
      }
    });

    function checkReady(){
      if (state.photos.front && state.photos.ingredients) {
        actions?.classList.remove('hidden');
      }
    }
  }

  function captureImage(callback){
    const overlay = document.createElement('div');
    overlay.className = 'camera-overlay';
    overlay.innerHTML = `
      <video autoplay playsinline></video>
      <button class="btn take">Take Photo</button>
      <button class="btn secondary cancel">Cancel</button>
    `;
    document.body.appendChild(overlay);

    const video = overlay.querySelector('video');
    const take = overlay.querySelector('.take');
    const cancel = overlay.querySelector('.cancel');

    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }).then(stream => {
      video.srcObject = stream;

      take.onclick = () => {
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        const url = canvas.toDataURL('image/jpeg');
        stream.getTracks().forEach(track => track.stop());
        overlay.remove();
        callback(url);
      };

      cancel.onclick = () => {
        stream.getTracks().forEach(track => track.stop());
        overlay.remove();
      };
    }).catch(err => {
      console.error('[camera error]', err);
      setMsg($('#newStatus'), 'Camera not available', 'error');
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    wireGlobal();
    wireLaunch();
    wireNewItem();
    wireReviewScreen();
    navigate('screenLaunch');
  });
})();
</script>