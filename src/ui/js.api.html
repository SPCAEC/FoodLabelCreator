<script>
/** Client wrapper around google.script.run (with normalization + fallbacks)
 *
 * Backwards-compatible change:
 * - API.extract(...) now accepts either:
 *    API.extract(frontBase64, ingredientsBase64)
 *  or API.extract({ frontDataUrl, ingDataUrl }) (object)
 *
 * This keeps changes minimal across files.
 */
(function () {
  function _gsr(method, ...args) {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject)[method](...args);
    });
  }

  // ---------- UPC normalization (client-side) ----------
  function normalizeUPC(raw) {
    let s = String(raw || '').replace(/\D/g, ''); // digits only
    // EAN-13 starting with 0 -> UPC-A 12
    if (s.length === 13 && s[0] === '0') s = s.slice(1);
    // If shorter (Sheet stored as number), left-pad
    if (s.length > 0 && s.length < 12) s = s.padStart(12, '0');
    return s;
  }

  // Helper: accept either full dataUrl or shorter keys
  function pickImageFromPayload(obj, preferFront = true) {
    if (!obj || typeof obj !== 'object') return null;
    // common keys we might see from calling code
    const candidates = preferFront
      ? ['frontDataUrl', 'front', 'frontImage', 'front_data_url', 'frontImageData']
      : ['ingDataUrl', 'ingredients', 'ingredientsDataUrl', 'ingredients_url', 'ing'];
    for (const k of candidates) {
      if (k in obj && obj[k]) return obj[k];
    }
    // also support english "ingredients" vs "ing"
    if (preferFront && obj.front) return obj.front;
    if (!preferFront && obj.ingredients) return obj.ingredients;
    return null;
  }

  // ---------- Public API ----------
  const API = {
    /** Lookup by UPC (send as {upc: '012345678905'}) */
    lookup(raw) {
      const upc = normalizeUPC(raw);
      if (upc.length !== 12) {
        // Keep client behavior predictable
        return Promise.resolve({ found: false, reason: 'invalid_length', sent: upc });
      }
      return _gsr('apiLookup', { upc });
    },

    /**
     * Create labels (and optionally save new/updated record)
     * Tries apiCreateLabels first; falls back to apiSaveAndCreateLabel for older backends.
     */
    createLabels(payload) {
      return _gsr('apiCreateLabels', payload)
        .catch(() => _gsr('apiSaveAndCreateLabel', payload));
    },

    /** Optional direct uploads (if your backend supports them) */
    uploadFront(upc, dataUrl) {
      const n = normalizeUPC(upc);
      return _gsr('apiUploadFront', n, dataUrl);
    },
    uploadIngredients(upc, dataUrl) {
      const n = normalizeUPC(upc);
      return _gsr('apiUploadIngredients', n, dataUrl);
    },

    /**
     * Extract label data from images.
     *
     * Supports two signatures:
     *  - extract(frontDataUrl, ingredientsDataUrl)
     *  - extract({ frontDataUrl, ingDataUrl })   // object form
     *
     * Maps to apiExtractFromImages({ front, ingredients })
     */
    extract(a, b) {
      // If caller passed a single object, handle object form
      if (arguments.length === 1 && a && typeof a === 'object') {
        const front = pickImageFromPayload(a, true) || null;
        const ingredients = pickImageFromPayload(a, false) || null;
        return _gsr('apiExtractFromImages', { front, ingredients });
      }

      // Otherwise expect two positional args (front, ingredients)
      const frontArg = (typeof a === 'string' && a) ? a : null;
      const ingArg = (typeof b === 'string' && b) ? b : null;
      return _gsr('apiExtractFromImages', { front: frontArg, ingredients: ingArg });
    }
  };

  // expose globally
  window.API = API;
})();
</script>